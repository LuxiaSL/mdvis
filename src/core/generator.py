from pathlib import Path
from typing import List, Optional
import autopep8

from src.core.parser import parse_file
from src.models.code_elements import Module, Class, Function
from src.utils.config import load_config
from src.core.visualizer import generate_global_dependency_diagram

def generate_anchor(label: str, prefix: str = "") -> str:
    """
    Generate an anchor by:
      - lowercasing the label
      - replacing spaces with dashes
      - optionally prepending a prefix
    Result is used in markdown as {#prefix-label}
    """
    anchor = label.lower().replace(" ", "-")
    return f"{prefix}-{anchor}" if prefix else anchor

def generate_frontmatter(module_obj: Module) -> str:
    """
    YAML frontmatter with extended metadata and more robust tags.
    If a module has classes, we consider it OOP, else purely functional.
    """
    # Basic tags
    tags = ["autogenerated", "python", "module"]
    # If we detect classes, let's note OOP
    if module_obj.classes:
        tags.append("OOP")
    # If there are top-level functions, we note that
    if module_obj.functions:
        tags.append("functional")

    # Convert tags to YAML array lines
    tag_lines = "\n".join([f"  - {t}" for t in tags])

    frontmatter_lines = [
        "---",
        f"title: {module_obj.name}",
        "doc_type: module",
        f"file_path: {module_obj.file_path}",
        f"classes: {len(module_obj.classes)}",
        f"functions: {len(module_obj.functions)}",
        f"imports: {len(module_obj.imports)}",
        f"lines_of_code: {module_obj.source.count(chr(10)) if module_obj.source else 0}",
        f"lint_errors: {len(module_obj.lint_warnings)}",
        "tags:",
        tag_lines,
        "---",
        ""
    ]
    return "\n".join(frontmatter_lines)

def render_imports(imports: list) -> str:
    """
    Render a list of imports as a Markdown section.
    If 'module' is None, it's a plain 'import X'. 
    Otherwise, it's 'from X import ...'.
    """
    if not imports:
        return ""
    md = "### Imports\n\n"
    for imp in imports:
        if imp.module:
            # e.g. "from foo import bar as baz"
            md += f"- **From** [[{imp.module}]] **import**:\n"
        else:
            # e.g. "import sys, os"
            md += "- **Import**:\n"
        for (name, alias) in imp.names:
            alias_part = f" as `{alias}`" if alias else ""
            md += f"  - `{name}`{alias_part}\n"
    md += "\n"
    return md

def render_docstring_as_callout(docstring: str) -> str:
    """
    Wrap docstring in a [!info] callout block to highlight it nicely.
    """
    lines = []
    lines.append("> [!info] Docstring")
    for line in docstring.splitlines():
        # Escape leading '>' to avoid nested blockquotes
        if line.strip().startswith(">"):
            line = "\\" + line
        lines.append(f"> {line}")
    lines.append("")  # blank line at end
    return "\n".join(lines)

def render_function(func: Function, level: int = 3) -> str:
    """
    Render a function or method (depending on parent_class).
    Distinguish 'Method:' for a class vs 'Function:' for a top-level function.
    """
    header = "#" * level
    is_method = bool(func.parent_class)
    anchor_prefix = "method" if is_method else "function"
    anchor = generate_anchor(func.name, prefix=anchor_prefix)
    title_text = "Method" if is_method else "Function"

    md = f"{header} {title_text}: `{func.name}` {{#{anchor}}}\n"
    # Also add a block reference ^method-xxx
    md += f"^{anchor}\n\n"

    # If docstring is present, display it in a callout
    if func.docstring:
        md += render_docstring_as_callout(func.docstring) + "\n"

    # Basic info
    md += f"**Parameters:** {', '.join(func.parameters) if func.parameters else 'None'}\n\n"

    # Decorators
    if func.decorators:
        md += "**Decorators:**\n\n"
        for dec in func.decorators:
            md += f"- `{dec}`\n"
        md += "\n"

    # Calls
    if func.calls:
        md += "#### Calls\n\n"
        # Each call is a chain, e.g. ["foo", "bar"]
        # We'll join with '.' to indicate foo.bar
        for call_obj in func.calls:
            chain = ".".join(call_obj.call_chain)
            md += f"- `{chain}`\n"
        md += "\n"

    # Nested functions
    if func.nested_functions:
        md += "#### Nested Functions\n\n"
        for nested in func.nested_functions:
            md += render_function(nested, level=level + 1)

    return md

def render_class(cls: Class) -> str:
    """
    Render a class as markdown with an anchor + block reference.
    """
    anchor = generate_anchor(cls.name, prefix="class")
    md = f"## Class: `{cls.name}` {{#{anchor}}}\n"
    md += f"^class-{anchor}\n\n"

    # Docstring callout
    if cls.docstring:
        md += render_docstring_as_callout(cls.docstring) + "\n"

    # If the class has base classes
    if cls.base_classes:
        base_list = ", ".join(cls.base_classes)
        md += f"**Extends:** {base_list}\n\n"

    # Methods
    if cls.methods:
        md += "### Methods\n\n"
        for method in cls.methods:
            md += render_function(method, level=4) + "\n"

    return md + "\n"

def render_module_structure(module_obj: Module) -> str:
    """
    Render the entire module's structure (imports, classes, functions).
    """
    anchor = generate_anchor(module_obj.name, prefix="module")
    md = f"## Module: `{module_obj.name}` {{#{anchor}}}\n"
    md += f"^module-{anchor}\n\n"

    # Imports
    md += render_imports(module_obj.imports)

    # Classes
    if module_obj.classes:
        md += "### Classes\n\n"
        for cls in module_obj.classes:
            md += render_class(cls)

    # Top-level Functions
    if module_obj.functions:
        md += "### Top-Level Functions\n\n"
        for func in module_obj.functions:
            md += render_function(func, level=3) + "\n"

    return md

def render_lint_warnings(module_obj: Module) -> str:
    """
    Show lint warnings in a [!warning] callout block.
    """
    if not module_obj.lint_warnings:
        return ""
    md = "## Lint Warnings\n\n"
    md += "> [!warning] Lint Issues\n"
    for w in module_obj.lint_warnings:
        md += f"> - {w}\n"
    md += "\n"
    return md

def render_todos(module_obj: Module) -> str:
    """
    Convert captured TODO items into tasks.
    """
    if not module_obj.todos:
        return ""
    md = "## TODOs\n\n"
    for todo in module_obj.todos:
        md += f"- [ ] {todo}\n"
    md += "\n"
    return md

def clean_code(source_code: str) -> str:
    """Autoformat code using autopep8 (in-memory)."""
    try:
        return autopep8.fix_code(source_code)
    except Exception as e:
        print(f"Warning: Code formatting failed: {e}")
        return source_code

def generate_markdown(
    file_path: str,
    root_dir: str,
    output_dir: str,
    source_code: Optional[str] = None,
    relative_path: Optional[Path] = None
) -> Optional[Module]:
    """
    Create a markdown doc for a Python file, preserving folder structure
    under 'output_dir'.
    """
    if relative_path is None:
        relative_path = Path(file_path).name

    output_subdir = Path(output_dir) / relative_path.parent
    output_subdir.mkdir(parents=True, exist_ok=True)
    markdown_file_name = f"{Path(file_path).stem}.md"
    output_path = output_subdir / markdown_file_name

    # Read or reuse source code
    if source_code is None:
        try:
            with open(file_path, "r", encoding="utf-8") as src_file:
                code_content = src_file.read()
        except Exception as e:
            print(f"Error reading {file_path}: {e}")
            return None
    else:
        code_content = source_code

    # Parse structure
    try:
        module_obj = parse_file(file_path)
    except Exception as e:
        print(f"Error parsing {file_path}: {e}")
        module_obj = None

    # Build final markdown
    markdown_content = ""
    if module_obj:
        markdown_content += generate_frontmatter(module_obj)

    file_name = Path(file_path).stem
    markdown_content += f"# {file_name}\n\n"
    # Provide a raw code block
    markdown_content += "## Raw Code\n\n"
    markdown_content += "```python\n" + code_content + "\n```\n\n"

    # If we parsed successfully, add warnings, todos, structure
    if module_obj:
        markdown_content += render_lint_warnings(module_obj)
        markdown_content += render_todos(module_obj)
        markdown_content += "## Parsed Structure\n\n"
        markdown_content += render_module_structure(module_obj)
    else:
        markdown_content += "> **Warning:** Parsing failed. No structural details available.\n"

    # Write to disk
    try:
        with open(output_path, "w", encoding="utf-8") as md_file:
            md_file.write(markdown_content)
        print(f"Generated markdown: {output_path}")
    except Exception as e:
        print(f"Error writing {output_path}: {e}")

    return module_obj

def generate_dashboard(modules: List[Module], output_directory: str) -> None:
    """
    Produce a central 'Dashboard.md' file that:
      - Lists all modules with links to their module anchor
      - Optionally includes a Mermaid diagram of imports
    """
    config = load_config()
    generate_diagrams = config.get("generate_diagrams", False)

    lines = ["# Codebase Dashboard", ""]
    lines.append("## Module Index\n")
    for m in modules:
        # We'll link to the 'module' anchor in the file
        anchor = generate_anchor(m.name, prefix="module")
        # e.g. [[MyModule#module-mymodule|MyModule]]
        link = f"[[{m.name}#{anchor}|{m.name}]]"
        lines.append(f"- {link} (Classes: {len(m.classes)}, Functions: {len(m.functions)})")

    # Optionally embed a mermaid dependency diagram
    if modules and generate_diagrams:
        lines.append("")
        lines.append("## Module Dependency Diagram\n")
        mermaid_code = generate_global_dependency_diagram(modules)
        if mermaid_code:
            lines.append(mermaid_code)

    dashboard_content = "\n".join(lines)
    output_dir = Path(output_directory)
    dashboard_file = output_dir / "Dashboard.md"
    try:
        with open(dashboard_file, "w", encoding="utf-8") as f:
            f.write(dashboard_content)
        print(f"Generated dashboard: {dashboard_file}")
    except Exception as e:
        print(f"Error writing dashboard {dashboard_file}: {e}")
